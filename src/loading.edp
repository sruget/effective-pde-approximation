// ============================================================================
// LOADING FUNCTIONS
// ============================================================================
// This module provides functions to generate right-hand side (RHS) loadings
// for the PDE problems. Multiple loadings are used to improve the robustness
// of the effective coefficient computation.
//
// Two types of loadings are available:
//   - coscosLoading: Cosine-based loadings with Gram-Schmidt orthogonalization
//   - sinsinLoading: Sine-based loadings with L2 normalization
// ============================================================================

// ============================================================================
// COSINE-COSINE LOADING WITH GRAM-SCHMIDT ORTHOGONALIZATION
// ============================================================================
// Generates a set of orthonormal loading functions based on cosine products:
//   f_p(x,y) = cos(nx_p * π * x) * cos(ny_p * π * y)
//
// The loadings are orthogonalized using a Gram-Schmidt process with respect
// to the boundary L2 inner product:
//   <f,g> = ∫_∂Ω f * g ds
//
// This ensures that the loadings are linearly independent, which improves
// the conditioning of the optimization problem.
//
// Parameters:
//   Th             - Computational mesh
//   nbSecondMember - Number of loading functions to generate
//
// Returns:
//   Matrix of size (nbSecondMember × ndof) containing the loading vectors
//
// Note:
//   The frequency pairs (nx, ny) are chosen to avoid redundancy. For example,
//   (3,3), (4,3), (3,4) are excluded as they are linear combinations of
//   other frequency pairs.
// ============================================================================
func real[int, int] coscosLoading(mesh &Th, int nbSecondMember)
{
	// Frequency pairs for cosine functions
	// Excludes redundant pairs: (3,3), (4,3), (3,4)
	real[int] nx = [1, 2, 1, 2, 3, 1, 3, 2, 4, 1, 4, 2, 5, 1, 5, 2];
	real[int] ny = [1, 1, 2, 2, 1, 3, 2, 3, 1, 4, 2, 4, 1, 5, 2, 5];

    fespace Vh(Th, P1);
	Vh getsizeofarray;
	Vh[int] RHS(nbSecondMember);
	real[int, int] RHStable(nbSecondMember, getsizeofarray[].n);

	for (int p = 0; p < nbSecondMember; p++){
		// Generate cosine-based loading
		RHS[p] = cos(nx[p]*pi*x)*cos(ny[p]*pi*y);

		// Gram-Schmidt orthogonalization against previous loadings
		for (int q = 0; q < p; q++){
			// Compute boundary L2 inner product <RHS[p], RHS[q]>
			real coef = int1d(Th, 1)(RHS[p]*RHS[q])   // Bottom boundary
			          + int1d(Th, 2)(RHS[p]*RHS[q])   // Right boundary
			          + int1d(Th, 3)(RHS[p]*RHS[q])   // Top boundary
			          + int1d(Th, 4)(RHS[p]*RHS[q]);  // Left boundary

			// Orthogonalize: RHS[p] = RHS[p] - <RHS[p], RHS[q]> * RHS[q]
			RHS[p][] -= coef*RHS[q][];
		}

		// Normalize to unit boundary L2 norm
		real rescalefactor = sqrt(int1d(Th, 1)(RHS[p]*RHS[p])
		                        + int1d(Th, 2)(RHS[p]*RHS[p])
		                        + int1d(Th, 3)(RHS[p]*RHS[p])
		                        + int1d(Th, 4)(RHS[p]*RHS[p]));
		RHS[p] = RHS[p] / rescalefactor;

		// Store in output matrix
		RHStable(p, :) = RHS[p][];
	}

	return RHStable;
}

// ============================================================================
// SINE-SINE LOADING WITH L2 NORMALIZATION
// ============================================================================
// Generates a set of normalized loading functions based on sine products:
//   f_p(x,y) = sin(nx_p * π * x) * sin(ny_p * π * y)
//
// Unlike coscosLoading, these loadings are NOT orthogonalized. They are
// simply normalized to unit L2 norm in the domain:
//   ||f_p||_L2(Ω) = 1
//
// Sine-based loadings satisfy homogeneous Dirichlet boundary conditions
// naturally (f = 0 on ∂Ω) and form a basis for domain-based problems.
//
// Parameters:
//   Th             - Computational mesh
//   nbSecondMember - Number of loading functions to generate
//
// Returns:
//   Matrix of size (nbSecondMember × ndof) containing the loading vectors
//
// Note:
//   These loadings are suitable for problems with homogeneous Dirichlet
//   boundary conditions where the source term is applied in the domain.
// ============================================================================
func real[int, int] sinsinLoading(mesh &Th, int nbSecondMember)
{
	// Frequency pairs for sine functions
	real[int] nx = [1, 2, 1, 2, 3, 1, 3, 2, 4, 1, 3, 4, 2, 4, 3, 5, 1, 5, 2];
	real[int] ny = [1, 1, 2, 2, 1, 3, 2, 3, 1, 4, 3, 2, 4, 3, 4, 1, 5, 2, 5];

    fespace Vh(Th, P1);
	Vh getsizeofarray;
	Vh[int] RHS(nbSecondMember);
	real[int, int] RHStable(nbSecondMember, getsizeofarray[].n);

	for (int p = 0; p < nbSecondMember; p++){
		// Generate sine-based loading
		RHS[p] = sin(nx[p]*pi*x)*sin(ny[p]*pi*y);

		// Normalize to unit L2 norm in domain
		real rescalefactor = sqrt(int2d(Th)(RHS[p]*RHS[p]));
		RHS[p] = RHS[p] / rescalefactor;

		// Store in output matrix
		RHStable(p, :) = RHS[p][];
	}

	return RHStable;
}
